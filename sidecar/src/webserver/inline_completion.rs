use axum::{response::IntoResponse, Extension, Json};
use tracing::error;

use crate::{
    application::application::Application,
    chunking::text_document::{Position, Range},
    in_line_agent::types::InLineAgent,
    inline_completion::types::{FillInMiddleCompletionAgent, InLineCompletionError},
};

use super::{
    model_selection::LLMClientConfig,
    types::{ApiResponse, Result},
};

#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct InlineCompletionRequest {
    pub filepath: String,
    pub language: String,
    pub text: String,
    pub position: Position,
    pub indentation: Option<String>,
    pub model_config: LLMClientConfig,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct InlineCompletion {
    pub insert_text: String,
    pub insert_range: Range,
}

impl InlineCompletion {
    pub fn new(insert_text: String, insert_range: Range) -> Self {
        Self {
            insert_text,
            insert_range,
        }
    }
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct InlineCompletionResponse {
    pub completions: Vec<InlineCompletion>,
}

impl InlineCompletionResponse {
    pub fn new(completions: Vec<InlineCompletion>) -> Self {
        Self { completions }
    }
}

impl ApiResponse for InlineCompletionResponse {}

pub async fn inline_completion(
    Extension(app): Extension<Application>,
    Json(InlineCompletionRequest {
        filepath,
        language,
        text,
        position,
        indentation,
        model_config,
    }): Json<InlineCompletionRequest>,
) -> Result<impl IntoResponse> {
    dbg!("we are over here");
    println!("we are getting here");
    println!("{:?}", &model_config);
    error!(event_name = "inline_completion",);
    let fill_in_middle_agent = FillInMiddleCompletionAgent::new(
        app.llm_broker.clone(),
        app.llm_tokenizer.clone(),
        app.answer_models.clone(),
        app.fill_in_middle_broker.clone(),
        app.editor_parsing.clone(),
    );
    let completions = fill_in_middle_agent
        .completion(InlineCompletionRequest {
            filepath,
            language,
            text,
            position,
            indentation,
            model_config,
        })
        .await
        // we should return a proper error over here
        .expect("to work");
    println!("{:?}", &completions);
    Ok(Json(completions))
}

#[cfg(test)]
mod tests {
    use super::InlineCompletionRequest;

    #[test]
    fn test_inline_completion_request_parsing() {
        let request = r#"{"filepath":"/Users/skcd/scratch/ide/extensions/codestory/src/sidecar/client.ts","language":"typescript","text":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport { sleep } from '../utilities/sleep';\nimport { CodeSymbolInformationEmbeddings, CodeSymbolKind } from '../utilities/types';\nimport { callServerEventStreamingBufferedGET, callServerEventStreamingBufferedPOST } from './ssestream';\nimport { ConversationMessage, EditFileResponse, getSideCarModelConfiguration, InEditorRequest, InEditorTreeSitterDocumentationQuery, InEditorTreeSitterDocumentationReply, InLineAgentMessage, Position, RepoStatus, SemanticSearchResponse, SidecarVariableType, SidecarVariableTypes, SnippetInformation, SyncUpdate, TextDocument } from './types';\nimport { SelectionDataForExplain } from '../utilities/getSelectionContext';\nimport { sidecarNotIndexRepository } from '../utilities/sidecarUrl';\nimport { getUserId } from '../utilities/uniqueId';\nimport { CompletionRequest, CompletionResponse } from '../inlineCompletion/sidecarCompletion';\n\nexport enum RepoRefBackend {\n\tlocal = 'local',\n\tgithub = 'github',\n}\n\n\nexport class RepoRef {\n\tprivate _path: string;\n\tprivate _backend: RepoRefBackend;\n\n\tconstructor(\n\t\tpath: string,\n\t\tbackend: RepoRefBackend\n\t) {\n\t\tthis._path = path;\n\t\tthis._backend = backend;\n\t}\n\n\tgetRepresentation(): string {\n\t\treturn `${this._backend}/${this._path}`;\n\t}\n\n\tgetPath(): string {\n\t\treturn this._path;\n\t}\n}\n\n\nexport class SideCarClient {\n\tprivate _url: string;\n\tprivate _openAIKey: string | null = null;\n\tprivate _modelConfiguration: vscode.ModelSelection;\n\tprivate _userId: string | null;\n\n\tconstructor(\n\t\turl: string,\n\t\topenAIKey: string | null,\n\t\tmodelConfiguration: vscode.ModelSelection,\n\t) {\n\t\tthis._url = url;\n\t\tthis._openAIKey = openAIKey;\n\t\tthis._modelConfiguration = modelConfiguration;\n\t\tthis._userId = getUserId();\n\t}\n\n\tupdateModelConfiguration(modelConfiguration: vscode.ModelSelection) {\n\t\tthis._modelConfiguration = modelConfiguration;\n\t}\n\n\tgetRepoListUrl(): string {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/repo/repo_list';\n\t\treturn baseUrl.toString();\n\t}\n\n\tasync getRangeForDiagnostics(\n\t\ttextDocumentWeb: TextDocument,\n\t\tsnippetInformation: SnippetInformation,\n\t\tthresholdToExpand: number,\n\t) {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/tree_sitter/diagnostic_parsing';\n\t\tconst body = {\n\t\t\ttext_document_web: textDocumentWeb,\n\t\t\trange: snippetInformation,\n\t\t\tthreshold_to_expand: thresholdToExpand,\n\t\t};\n\t\tconst url = baseUrl.toString();\n\t\tconst response = await fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t\tconst responseJson = await response.json();\n\t\tconsole.log(responseJson);\n\t}\n\n\tasync getSymbolsForGoToDefinition(\n\t\tcodeSnippet: string,\n\t\trepoRef: RepoRef,\n\t\tthreadId: string,\n\t\tlanguage: string,\n\t): Promise<string[]> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/agent/goto_definition_symbols';\n\t\tconst body = {\n\t\t\trepo_ref: repoRef.getRepresentation(),\n\t\t\tcode_snippet: codeSnippet,\n\t\t\tthread_id: threadId,\n\t\t\tlanguage: language,\n\t\t\topenai_key: this._openAIKey,\n\t\t};\n\t\tconst url = baseUrl.toString();\n\t\tconst response = await fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t\tconst responseJson = await response.json();\n\t\tconst symbols = responseJson.symbols as string[];\n\t\treturn symbols;\n\t}\n\n\tasync getRepoStatus(): Promise<RepoStatus> {\n\t\tconst response = await fetch(this.getRepoListUrl());\n\t\tconst repoList = (await response.json()) as RepoStatus;\n\t\treturn repoList;\n\t}\n\n\n\tasync *getRepoSyncStatus(): AsyncIterableIterator<SyncUpdate> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/repo/status';\n\t\tconst url = baseUrl.toString();\n\t\tconst asyncIterableResponse = await callServerEventStreamingBufferedGET(url);\n\t\tfor await (const line of asyncIterableResponse) {\n\t\t\tconst lineParts = line.split('data:{');\n\t\t\tfor (const lineSinglePart of lineParts) {\n\t\t\t\tconst lineSinglePartTrimmed = lineSinglePart.trim();\n\t\t\t\tif (lineSinglePartTrimmed === '') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst finalString = '{' + lineSinglePartTrimmed;\n\t\t\t\tconst syncUpdate = JSON.parse(finalString) as SyncUpdate;\n\t\t\t\tyield syncUpdate;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tasync *getInLineEditorResponse(\n\t\tcontext: InEditorRequest,\n\t): AsyncIterableIterator<InLineAgentMessage> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/in_editor/answer';\n\t\tconst url = baseUrl.toString();\n\t\tconst sideCarModelConfiguration = await getSideCarModelConfiguration(await vscode.modelSelection.getConfiguration());\n\t\t// This is where we have to send the model selection object\n\t\t// const modelConfig = {\n\t\t// \tslow_model: this._modelConfiguration.slowModel,\n\t\t// \tfast_model: this._modelConfiguration.fastModel,\n\t\t// \tmodels: this._modelConfiguration.models,\n\t\t// \tproviders,\n\t\t// };\n\t\tconsole.log(JSON.stringify(sideCarModelConfiguration));\n\t\tconst finalContext = {\n\t\t\t...context,\n\t\t\topenai_key: this._openAIKey,\n\t\t\tmodelConfig: sideCarModelConfiguration,\n\t\t\tuserId: this._userId,\n\t\t};\n\t\tconst asyncIterableResponse = await callServerEventStreamingBufferedPOST(url, finalContext);\n\t\tfor await (const line of asyncIterableResponse) {\n\t\t\tconst lineParts = line.split('data:{');\n\t\t\tfor (const lineSinglePart of lineParts) {\n\t\t\t\tconst lineSinglePartTrimmed = lineSinglePart.trim();\n\t\t\t\tif (lineSinglePartTrimmed === '') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst inlineAgentMessage = JSON.parse('{' + lineSinglePartTrimmed) as InLineAgentMessage;\n\t\t\t\tyield inlineAgentMessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getParsedComments(\n\t\tcontext: InEditorTreeSitterDocumentationQuery,\n\t): Promise<InEditorTreeSitterDocumentationReply> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/tree_sitter/documentation_parsing';\n\t\tconst url = baseUrl.toString();\n\t\tconst response = await fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t\tbody: JSON.stringify(context),\n\t\t});\n\t\tconst responseJson = await response.json();\n\t\treturn responseJson as InEditorTreeSitterDocumentationReply;\n\t}\n\n\tasync *editFileRequest(\n\t\tfilePath: string,\n\t\tfileContent: string,\n\t\tlanguage: string,\n\t\tllmContent: string,\n\t\tuserQuery: string,\n\t\tcodeBlockIndex: number,\n\t\tsessionId: string,\n\t): AsyncIterableIterator<EditFileResponse> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/file/edit_file';\n\t\tconst url = baseUrl.toString();\n\t\tconst sideCarModelConfiguration = await getSideCarModelConfiguration(await vscode.modelSelection.getConfiguration());\n\t\tconst body = {\n\t\t\tfile_path: filePath,\n\t\t\tfile_content: fileContent,\n\t\t\tlanguage: language,\n\t\t\tnew_content: llmContent,\n\t\t\tuser_query: userQuery,\n\t\t\tsession_id: sessionId,\n\t\t\tcode_block_index: codeBlockIndex,\n\t\t\topenai_key: this._openAIKey,\n\t\t\tuserId: this._userId,\n\t\t\tmodel_config: sideCarModelConfiguration,\n\t\t};\n\t\tconst asyncIterableResponse = await callServerEventStreamingBufferedPOST(url, body);\n\t\tfor await (const line of asyncIterableResponse) {\n\t\t\tconst lineParts = line.split('data:{');\n\t\t\tfor (const lineSinglePart of lineParts) {\n\t\t\t\tconst lineSinglePartTrimmed = lineSinglePart.trim();\n\t\t\t\tif (lineSinglePartTrimmed === '') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst editFileResponse = JSON.parse('{' + lineSinglePartTrimmed) as EditFileResponse;\n\t\t\t\tyield editFileResponse;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync *followupQuestion(\n\t\tquery: string,\n\t\trepoRef: RepoRef,\n\t\tthreadId: string,\n\t\tvariables: Record<string, vscode.CSChatVariableValue[]>,\n\t\tprojectLabels: string[],\n\t): AsyncIterableIterator<ConversationMessage> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/agent/followup_chat';\n\t\tconst url = baseUrl.toString();\n\t\tconst activeWindowData = getCurrentActiveWindow();\n\t\tconst sideCarModelConfiguration = await getSideCarModelConfiguration(await vscode.modelSelection.getConfiguration());\n\t\tconst body = {\n\t\t\trepo_ref: repoRef.getRepresentation(),\n\t\t\tquery: query,\n\t\t\tthread_id: threadId,\n\t\t\tuser_context: await convertVSCodeVariableToSidecar(variables),\n\t\t\tproject_labels: projectLabels,\n\t\t\tactive_window_data: activeWindowData,\n\t\t\topenai_key: this._openAIKey,\n\t\t\tmodel_config: sideCarModelConfiguration,\n\t\t\tuser_id: this._userId,\n\t\t};\n\t\tconst asyncIterableResponse = await callServerEventStreamingBufferedPOST(url, body);\n\t\tfor await (const line of asyncIterableResponse) {\n\t\t\tconst lineParts = line.split('data:{');\n\t\t\tfor (const lineSinglePart of lineParts) {\n\t\t\t\tconst lineSinglePartTrimmed = lineSinglePart.trim();\n\t\t\t\tif (lineSinglePartTrimmed === '') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconsole.log(lineSinglePartTrimmed);\n\t\t\t\tconst conversationMessage = JSON.parse('{' + lineSinglePartTrimmed) as ConversationMessage;\n\t\t\t\tyield conversationMessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync *explainQuery(\n\t\tquery: string,\n\t\trepoRef: RepoRef,\n\t\tselection: SelectionDataForExplain,\n\t\tthreadId: string,\n\t): AsyncIterableIterator<ConversationMessage> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/agent/explain';\n\t\tbaseUrl.searchParams.set('repo_ref', repoRef.getRepresentation());\n\t\tbaseUrl.searchParams.set('query', query);\n\t\tbaseUrl.searchParams.set('start_line', selection.lineStart.toString());\n\t\tbaseUrl.searchParams.set('end_line', selection.lineEnd.toString());\n\t\tbaseUrl.searchParams.set('relative_path', selection.relativeFilePath);\n\t\tbaseUrl.searchParams.set('thread_id', threadId);\n\t\tif (this._openAIKey !== null) {\n\t\t\tbaseUrl.searchParams.set('openai_key', this._openAIKey);\n\t\t}\n\t\tconst url = baseUrl.toString();\n\t\tconst asyncIterableResponse = await callServerEventStreamingBufferedGET(url);\n\t\tfor await (const line of asyncIterableResponse) {\n\t\t\tconst lineParts = line.split('data:{');\n\t\t\tfor (const lineSinglePart of lineParts) {\n\t\t\t\tconst lineSinglePartTrimmed = lineSinglePart.trim();\n\t\t\t\tif (lineSinglePartTrimmed === '') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst conversationMessage = JSON.parse('{' + lineSinglePartTrimmed) as ConversationMessage;\n\t\t\t\tyield conversationMessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync *searchQuery(\n\t\tquery: string,\n\t\trepoRef: RepoRef,\n\t\tthreadId: string,\n\t): AsyncIterableIterator<ConversationMessage> {\n\t\t// how do we create the url properly here?\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/agent/search_agent';\n\t\tbaseUrl.searchParams.set('reporef', repoRef.getRepresentation());\n\t\tbaseUrl.searchParams.set('query', query);\n\t\tbaseUrl.searchParams.set('thread_id', threadId);\n\t\tconst url = baseUrl.toString();\n\t\tconst asyncIterableResponse = await callServerEventStreamingBufferedGET(url);\n\t\tfor await (const line of asyncIterableResponse) {\n\t\t\t// Now these responses can be parsed properly, since we are using our\n\t\t\t// own reader over sse, sometimes the reader might send multiple events\n\t\t\t// in a single line so we should split the lines by \\n to get the\n\t\t\t// individual lines\n\t\t\t// console.log(line);\n\t\t\t// Is this a good placeholder? probably not, cause we can have instances\n\t\t\t// of this inside the string too, but for now lets check if this works as\n\t\t\t// want it to\n\t\t\tconst lineParts = line.split('data:{');\n\t\t\tfor (const lineSinglePart of lineParts) {\n\t\t\t\tconst lineSinglePartTrimmed = lineSinglePart.trim();\n\t\t\t\tif (lineSinglePartTrimmed === '') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst conversationMessage = JSON.parse('{' + lineSinglePartTrimmed) as ConversationMessage;\n\t\t\t\tconsole.log('[search][stream] whats the message from the stream');\n\t\t\t\tyield conversationMessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync inlineCompletion(\n\t\tcompletionRequest: CompletionRequest,\n\t\tsignal: AbortSignal,\n\t): Promise<CompletionResponse> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tconsole.log(\"are we over here in inline completions\");\n\t\tconst sideCarModelConfiguration = await getSideCarModelConfiguration(await vscode.modelSelection.getConfiguration());\n\t\tbaseUrl.pathname = '/api/inline_completion';\n\n\t\tconst body = {\n\t\t\tfilepath: completionRequest.filepath,\n\t\t\tlanguage: completionRequest.language,\n\t\t\ttext: completionRequest.text,\n\t\t\t// The cursor position in the editor\n\t\t\tposition: {\n\t\t\t\tline: completionRequest.position.line,\n\t\t\t\tcharacter: completionRequest.position.character,\n\t\t\t\tbyteOffset: completionRequest.position.byteOffset,\n\t\t\t},\n\t\t\tmodel_config: sideCarModelConfiguration,\n\t\t};\n\t\tconsole.log(\"json string message\");\n\t\tconsole.log(\"\" + JSON.stringify(body));\n\t\tconsole.log(body);\n\t\t// s\n\t\tconst url = baseUrl.toString();\n\n\t\t// Create an instance of AbortController\n\t\tconst controller = new AbortController();\n\t\tconst { signal: abortSignal } = controller;\n\n\t\t// Combine the provided signal with the abortSignal\n\t\tconst combinedSignal = AbortSignal.abort([signal, abortSignal]);\n\n\t\t// Set the combinedSignal as the signal option in the fetch request\n\t\tconst response = await fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t\tsignal: combinedSignal, // Use the combined signal\n\t\t});\n\n\t\t// Check if the request was aborted\n\t\tif (signal.aborted) {\n\t\t\t// Send termination notification to the server\n\t\t\tawait fetch(url, {\n\t\t\t\tmethod: 'DELETE',\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tcompletions: [],\n\t\t\t}\n\t\t}\n\n\t\tconst responseJson = await response.json();\n\t\tconsole.log(responseJson);\n\t\treturn responseJson;\n\t}\n\n\n\tasync indexRepositoryIfNotInvoked(repoRef: RepoRef): Promise<boolean> {\n\t\t// First get the list of indexed repositories\n\t\tawait this.waitForGreenHC();\n\t\tconsole.log('fetching the status of the various repositories');\n\t\tconst response = await fetch(this.getRepoListUrl());\n\t\tconst repoList = (await response.json()) as RepoStatus;\n\t\tif (sidecarNotIndexRepository()) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(repoRef.getRepresentation() in repoList.repo_map)) {\n\t\t\t// We need to index this repository\n\t\t\tconst baseUrl = new URL(this._url);\n\t\t\tbaseUrl.pathname = '/api/repo/sync';\n\t\t\tbaseUrl.searchParams.set('repo', repoRef.getRepresentation());\n\t\t\tif (this._openAIKey !== null) {\n\t\t\t\tbaseUrl.searchParams.set('openai_key', this._openAIKey);\n\t\t\t}\n\t\t\tconst url = baseUrl.toString();\n\t\t\tconst response = await fetch(url);\n\t\t\tconst responseJson = await response.json();\n\t\t\treturn responseJson.status === 'ok';\n\t\t} else {\n\t\t\t// We don't need to index this repository\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tasync waitForGreenHC(): Promise<boolean> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/health';\n\t\tlet attempts = 0;\n\t\tconst totalAttempts = 10;\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tconsole.log('trying to HC for repo check');\n\t\t\t\tconst url = baseUrl.toString();\n\t\t\t\tconst response = await fetch(url);\n\t\t\t\treturn response.status === 200;\n\t\t\t} catch (e) {\n\t\t\t\t// sleeping for a attempts * second here\n\t\t\t\tawait sleep(1000 * (attempts + 1));\n\t\t\t\tattempts = attempts + 1;\n\t\t\t\tif (attempts < totalAttempts) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getSemanticSearchResult(\n\t\tquery: string,\n\t\treporef: RepoRef,\n\t): Promise<CodeSymbolInformationEmbeddings[]> {\n\t\tconst baseUrl = new URL(this._url);\n\t\tbaseUrl.pathname = '/api/agent/hybrid_search';\n\t\tbaseUrl.searchParams.set('repo', reporef.getRepresentation());\n\t\tbaseUrl.searchParams.set('query', query);\n\t\tif (this._openAIKey !== null) {\n\t\t\tbaseUrl.searchParams.set('openai_key', this._openAIKey);\n\t\t}\n\t\tconst url = baseUrl.toString();\n\t\tconst response = await fetch(url);\n\t\tconst responseJson = await response.json();\n\t\tconst semanticSearchResult = responseJson as SemanticSearchResponse;\n\t\tconst codeSymbols = semanticSearchResult.code_spans;\n\t\tconst sortedCodeSymbols = codeSymbols.sort((a, b) => {\n\t\t\tif (b.score !== null && a.score !== null) {\n\t\t\t\treturn b.score - a.score;\n\t\t\t}\n\t\t\tif (b.score !== null && a.score === null) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (b.score === null && a.score !== null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t\tconst codeSymbolInformationEmbeddings: CodeSymbolInformationEmbeddings[] = sortedCodeSymbols.map((codeSpan) => {\n\t\t\tconst filePath = path.join(reporef.getPath(), codeSpan.file_path);\n\t\t\treturn {\n\t\t\t\tcodeSymbolInformation: {\n\t\t\t\t\tsymbolName: '',\n\t\t\t\t\tsymbolKind: CodeSymbolKind.null,\n\t\t\t\t\tsymbolStartLine: codeSpan.start_line,\n\t\t\t\t\tsymbolEndLine: codeSpan.end_line,\n\t\t\t\t\tcodeSnippet: {\n\t\t\t\t\t\tlanguageId: 'typescript',\n\t\t\t\t\t\tcode: codeSpan.data,\n\t\t\t\t\t},\n\t\t\t\t\textraSymbolHint: null,\n\t\t\t\t\tdependencies: [],\n\t\t\t\t\tfsFilePath: filePath,\n\t\t\t\t\toriginalFilePath: filePath,\n\t\t\t\t\tworkingDirectory: reporef.getPath(),\n\t\t\t\t\tdisplayName: '',\n\t\t\t\t\toriginalName: '',\n\t\t\t\t\toriginalSymbolName: '',\n\t\t\t\t\tglobalScope: 'global',\n\t\t\t\t},\n\t\t\t\tcodeSymbolEmbedding: [],\n\t\t\t\tfileHash: '',\n\t\t\t};\n\t\t});\n\t\treturn codeSymbolInformationEmbeddings;\n\t}\n}\n\ninterface CodeSelectionUriRange {\n\turi: string;\n\trange: {\n\t\tselection: {\n\t\t\tstartLineNumber: number;\n\t\t\tstartColumn: number;\n\t\t\tendLineNumber: number;\n\t\t\tendColumn: number;\n\t\t};\n\t\tdecoration: {\n\t\t\tstartLineNumber: number;\n\t\t\tstartColumn: number;\n\t\t\tendLineNumber: number;\n\t\t\tendColumn: number;\n\t\t};\n\t};\n}\n\nasync function convertVSCodeVariableToSidecar(\n\tvariables: Record<string, vscode.CSChatVariableValue[]>,\n): Promise<{ variables: SidecarVariableTypes[]; file_content_map: { file_path: string; file_content: string; language: string }[] }> {\n\tconst sidecarVariables: SidecarVariableTypes[] = [];\n\tconst fileCache: Map<string, vscode.TextDocument> = new Map();\n\tconst resolvedFileCache: Map<string, [string, string]> = new Map();\n\tconst variablesArr = Array.from(new Map(Object.entries(variables)).entries());\n\tfor (let index = 0; index < variablesArr.length; index++) {\n\t\tconst keyValue = variablesArr[index];\n\t\tconst name = keyValue[0];\n\t\tconst value = keyValue[1];\n\t\tif (value.length === 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst variableValue = value[0];\n\t\tif (typeof variableValue.value === 'string') {\n\t\t\t// TODO write code from here for the selection logic\n\t\t\tconst parsedJson = JSON.parse(variableValue.value) as CodeSelectionUriRange;\n\t\t\tconst filePath = vscode.Uri.parse(parsedJson.uri);\n\t\t\tconst cachedFile = fileCache.get(filePath.fsPath);\n\t\t\tif (cachedFile === undefined) {\n\t\t\t\tconst fileDocument = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath.fsPath));\n\t\t\t\tfileCache.set(filePath.fsPath, fileDocument);\n\t\t\t}\n\t\t\tconst fileDocument = fileCache.get(filePath.fsPath) as vscode.TextDocument;\n\t\t\tconst startRange = {\n\t\t\t\tline: parsedJson.range.selection.startLineNumber,\n\t\t\t\tcharacter: parsedJson.range.selection.startColumn,\n\t\t\t};\n\t\t\tconst endRange = {\n\t\t\t\tline: parsedJson.range.selection.endLineNumber,\n\t\t\t\tcharacter: parsedJson.range.selection.endColumn,\n\t\t\t};\n\t\t\tconst variableType = getVariableType(\n\t\t\t\tname,\n\t\t\t\tstartRange,\n\t\t\t\tendRange,\n\t\t\t\tfileDocument,\n\t\t\t);\n\t\t\tconst content = fileDocument.getText(new vscode.Range(\n\t\t\t\tnew vscode.Position(startRange.line, startRange.character),\n\t\t\t\tnew vscode.Position(endRange.line, endRange.character),\n\t\t\t));\n\t\t\tresolvedFileCache.set(filePath.fsPath, [fileDocument.getText(), fileDocument.languageId]);\n\t\t\tif (variableType !== null) {\n\t\t\t\tsidecarVariables.push({\n\t\t\t\t\tname,\n\t\t\t\t\tstart_position: startRange,\n\t\t\t\t\tend_position: endRange,\n\t\t\t\t\tfs_file_path: filePath.fsPath,\n\t\t\t\t\ttype: variableType,\n\t\t\t\t\tcontent,\n\t\t\t\t\tlanguage: fileDocument.languageId,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst parsedValue = variableValue.value as any;\n\t\t\tconst fsFilePath = parsedValue.uri.fsPath;\n\t\t\tconst cachedFile = fileCache.get(fsFilePath);\n\t\t\tif (cachedFile === undefined) {\n\t\t\t\tconst fileDocument = await vscode.workspace.openTextDocument(vscode.Uri.file(fsFilePath));\n\t\t\t\tfileCache.set(fsFilePath, fileDocument);\n\t\t\t}\n\t\t\tconst fileDocument = fileCache.get(fsFilePath) as vscode.TextDocument;\n\t\t\tconst startRange = {\n\t\t\t\tline: parsedValue.range.startLineNumber,\n\t\t\t\tcharacter: parsedValue.range.startColumn,\n\t\t\t};\n\t\t\tconst endRange = {\n\t\t\t\tline: parsedValue.range.endLineNumber,\n\t\t\t\tcharacter: parsedValue.range.endColumn,\n\t\t\t};\n\t\t\tconst variableType = getVariableType(\n\t\t\t\tname,\n\t\t\t\tstartRange,\n\t\t\t\tendRange,\n\t\t\t\tfileDocument,\n\t\t\t);\n\t\t\tconst content = fileDocument.getText(new vscode.Range(\n\t\t\t\tnew vscode.Position(startRange.line, startRange.character),\n\t\t\t\tnew vscode.Position(endRange.line, endRange.character),\n\t\t\t));\n\t\t\tresolvedFileCache.set(fsFilePath, [fileDocument.getText(), fileDocument.languageId]);\n\t\t\tif (variableType !== null) {\n\t\t\t\tsidecarVariables.push({\n\t\t\t\t\tname,\n\t\t\t\t\tstart_position: startRange,\n\t\t\t\t\tend_position: endRange,\n\t\t\t\t\tfs_file_path: fsFilePath,\n\t\t\t\t\ttype: variableType,\n\t\t\t\t\tcontent,\n\t\t\t\t\tlanguage: fileDocument.languageId,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tvariables: sidecarVariables,\n\t\tfile_content_map: Array.from(resolvedFileCache.entries()).map(([filePath, fileContent]) => {\n\t\t\treturn {\n\t\t\t\tfile_path: filePath,\n\t\t\t\tfile_content: fileContent[0],\n\t\t\t\tlanguage: fileContent[1],\n\t\t\t};\n\t\t}),\n\t};\n}\n\nfunction getVariableType(\n\tname: string,\n\tstartPosition: Position,\n\tendPosition: Position,\n\ttextDocument: vscode.TextDocument,\n): SidecarVariableType | null {\n\tif (name.startsWith('file')) {\n\t\t// here we have to check if the range is the full file or just a partial\n\t\t// range in which case its a selection\n\t\tconst textLines = textDocument.lineCount;\n\t\tif (startPosition.line === 1 && endPosition.line === textLines) {\n\t\t\treturn 'File';\n\t\t} else {\n\t\t\treturn 'Selection';\n\t\t}\n\t}\n\treturn 'CodeSymbol';\n}\n\nfunction getCurrentActiveWindow(): {\n\tfile_path: string;\n\tfile_content: string;\n\tvisible_range_content: string;\n\tstart_line: number;\n\tend_line: number;\n\tlanguage: string;\n} | undefined {\n\tconst activeWindow = vscode.window.activeTextEditor;\n\tif (activeWindow === undefined) {\n\t\treturn undefined;\n\t}\n\tif (activeWindow.visibleRanges.length == 0) {\n\t\t// Then we return the full length of the file here or otherwise\n\t\t// we return whats present in the range\n\t\treturn undefined;\n\t}\n\tconst visibleRanges = activeWindow.visibleRanges;\n\tconst startPosition = activeWindow.visibleRanges[0].start;\n\tconst endPosition = activeWindow.visibleRanges[visibleRanges.length - 1].end;\n\tconst fsFilePath = activeWindow.document.uri.fsPath;\n\tlet range = new vscode.Range(\n\t\tstartPosition.line,\n\t\t0,\n\t\tendPosition.line,\n\t\tactiveWindow.document.lineAt(endPosition.line).text.length\n\t);\n\tconst visibleRagneContents = activeWindow.document.getText(range);\n\tconst contents = activeWindow.document.getText();\n\treturn {\n\t\tfile_path: fsFilePath,\n\t\tfile_content: contents,\n\t\tvisible_range_content: visibleRagneContents,\n\t\t// as these are 0 indexed\n\t\tstart_line: startPosition.line + 1,\n\t\tend_line: endPosition.line + 1,\n\t\tlanguage: activeWindow.document.languageId,\n\t};\n}\n","position":{"line":370,"character":6,"byteOffset":12621},"model_config":{"slow_model":"Gpt4","fast_model":"GPT3_5_16k","models":{"Gpt4":{"context_length":8192,"temperature":0.2,"provider":{"CodeStory":{"llm_type":"Gpt4"}}},"GPT3_5_16k":{"context_length":16385,"temperature":0.2,"provider":{"CodeStory":{"llm_type":"GPT3_5_16k"}}},"Gpt4Turbo":{"context_length":128000,"temperature":0.2,"provider":{"Azure":{"deployment_id":"gpt-4-turbo"}}},"Mixtral":{"context_length":32000,"temperature":0.2,"provider":"TogetherAI"},"MistralInstruct":{"context_length":8000,"temperature":0.2,"provider":"Ollama"},"CodeLlama13BInstruct":{"context_length":16384,"temperature":0.2,"provider":"TogetherAI"},"codestory/export-to-codebase-openhermes-full":{"context_length":8192,"temperature":0.2,"provider":"Ollama"},"CodeLLama70BInstruct":{"context_length":100000,"temperature":0.6,"provider":"TogetherAI"}},"providers":[{"OpenAIAzureConfig":{"deployment_id":"","api_base":"https://codestory-gpt4.openai.azure.com","api_key":"89ca8a49a33344c9b794b3dabcbbc5d0","api_version":"2023-08-01-preview"}},{"TogetherAI":{"api_key":"cc10d6774e67efef2004b85efdb81a3c9ba0b7682cc33d59c30834183502208d"}},{"Ollama":{}}]}} "#;
        let parsed_request = dbg!(serde_json::from_str::<InlineCompletionRequest>(request));
        assert!(parsed_request.is_ok());
    }
}
